package main

import (
	"encoding/json"
	"fmt"
	"html/template"
	"io/ioutil"
	"net/http"
	"strings"
)

var handlers = map[string]func(string) string{
	"ButtonCountercountUp": buttonCounterCountUp,
}

type NewUIUpdateReq struct {
	Method    string `json:"method"`
	Component string `json:"component"`
}

func runHandler(method, component, body string) string {
	handle := handlers[component+method]
	if handle != nil {
		return handle(body)
	}
	return "component method not found"
}

func NeUIUpdate(w http.ResponseWriter, r *http.Request) {
	body, err := ioutil.ReadAll(r.Body)
	if err != nil {
		panic(err)
	}
	var t NewUIUpdateReq
	err = json.Unmarshal(body, &t)
	if err != nil {
		panic(err)
	}

	json := runHandler(t.Method, t.Component, string(body))
	w.Header().Set("Content-Type", "application/json")
	w.Write([]byte(json))
}

func buttonCounterCountUp(body string) string {
	var t buttonCounterState
	err := json.Unmarshal([]byte(body), &t)
	if err != nil {
		panic(err)
	}

	t.countUp()
	var s strings.Builder
	template.Must(template.ParseFiles("/Users/brandonatkinson/Desktop/web_tests/NeUI/GeneratedCodeServer/ButtonCounterTempate.html")).Execute(&s, t)
	return fmt.Sprintf("{\"html\": \"%s\", \"autoGeneratedPropIDForCount\": %d}", filterNewLines(s.String()), t.Count)
}

func filterNewLines(s string) string {
	return strings.Map(func(r rune) rune {
		switch r {
		case 0x000A, 0x000B, 0x000C, 0x000D, 0x0085, 0x2028, 0x2029:
			return -1
		default:
			return r
		}
	}, s)
}
